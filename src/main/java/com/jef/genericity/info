<? extends E>是Upper Bound(上限)的通配符,用来限制元素类型的上限,如:

List<? extends Fruit> fruits;

表示集合中的元素的上限是Fruit类型,即只能是Fruit或者Fruit的子类,如:

fruits = new ArrayList<Fruits>();

fruits = new ArrayList<Apple>();

都是合理的,但是如果是Fruit的父类就会报错,如:

fruits = new  ArrayList<Object>();

编译会报错。

1.写入

fruits.add(new Apple());报错

因为集合fruits中装的元素类型为Fruit或Fruit子类,直觉告诉我们,往fruits中添加一个Fruit类型对象或其子类对象是可行的,结果是编译都不通过,为什么?因为<? extends Fruit>只是告诉编译器集合中元素的类型上限,但它具体是什么类型编译器是不知道的,fruits可以指向ArrayList<Fruit>,也可以指向ArrayList<Apple>、ArrayList<Banana>,也就是说它的类型是不确定的,既然是不确定的,为了类型安全,编译器只能阻止添加元素了。举个例子,当你添加一个Apple时,但fruits此时指向ArrayList<Banana>,显然类型就不兼容了。当然null除外,因为它可以表示任何类型

2.读取

Fruit fruit = fruits.get(0);

无论fruits指向什么,编译器都可以确定获取的元素是Fruit类型,所有读取集合中的元素是允许的



<? super E>是 Lower Bound(下限) 的通配符 ,用来限制元素的类型下限,比如

List<? super Apple> apples;

表示集合中元素类型下限为Apple类型,即只能是Apple或Apple的父类,因此对于下面的赋值是合理的

apples = new ArrayList<Apple>();  

如果元素是apple的子类,则编译不通过

apple = new ArrayList<RedApple>();报错

1.写入

因为apples中装的元素是Apple或Apple的某个父类,我们无法确定是哪个具体类型,但是可以确定的是Apple和Apple的子类是和这个“不确定的类”兼容的,因为它肯定是这个“不确定类型”的子类,也就是说我们可以往集合中添加Apple或者Apple子类的对象,所以对于下面的添加是允许的

apples.add(new Apple()); 

 apples.add(new RedApple());  



它无法添加Fruit的任何父类对象,举个例子,当你往apples中添加一个Fruit类型对象时,但此时apples指向ArrayList<Apple>,显然类型就不兼容了,Fruit不是Apple的子类

apples.add(new Fruit());

2.读取

编译器允许从apples中获取元素的,但是无法确定的获取的元素具体是什么类型,只能确定一定是Object类型的子类,因此我们想获得存储进去的对应类型的元素就只能进行强制类型转换了

Apple apple = (Apple)apples.get(0);

